# 实验17 Socket 应用程序设计

## 17.1 背景知识

**Socket（套接字）** 最初是由美国 Berkeley College of California University 为 BSD Unix 操作系统开发的网络通信接口。随着 Unix 操作系统的广泛使用，套接字成为当时及现在最流行的网络通信应用程序接口之一。**Windows Sockets** 是 Berkeley Sockets 在 Windows 环境下的扩充，它为 Windows 下网络编程提供了一套标准的网络程序设计接口。

### （1）Windows Sockets API

**Windows Sockets API（Application Program Interface）** 是 Microsoft Windows 的网络接口，它包括一个 Berkeley Sockets 功能调用的集合，以及为 Windows 所作的扩充。

Windows Sockets 规范的目的是提供给应用程序开发者一套简单的 API，并让各家网络软件供应商共同遵守。Windows 网络编程接口不仅包含了人们所熟悉的 Berkeley Socket 风格的库函数调用，还包含了一组针对 Windows 的扩展函数，使程序员能充分地利用 Windows 消息驱动机制进行编程。

此外，在一个特定版本 Windows 的基础上，Windows Sockets 也定义了一个 **二进制接口（ABI）**，以此保证应用 Windows Sockets API 的应用程序能够在任何网络软件供应商的符合 Windows Sockets 协议的实现上工作。因此，该规范定义了应用程序开发者能使用的接口，并且网络软件供应商能够实现的一套库函数调用和相关设置。

遵守这些 Windows Sockets 规范的网络软件，称为 **Windows Sockets 兼容的**。而 Windows Sockets 兼容实现的提供者，称为 **Windows Sockets 提供者**。一个网络软件供应商必须充分地实现 Windows Sockets 规范才能做到与 Windows Sockets 兼容。任何能够与 Windows Sockets 兼容实现协同工作的应用程序就被认为是 **有 Windows Sockets 接口的**，这种应用程序称为 **Windows Sockets 应用程序**。

Windows Sockets 规范定义并记录了如何使用 API 与 **Internet 协议（IPS，通常指 TCP/IP）** 连接。尤其要指出的是，所有的 Windows Sockets 实现都支持流套接字和数据报套接字。应用程序调用 Windows Sockets 的 API 实现相互之间的通信，Windows Sockets 又利用下层的网络通讯协议功能和操作系统调用实现实际的通讯工作。它们之间的关系如图 15-1 所示。
![alt text](image.png)


Windows Sockets 的发展从 20 世纪 90 年代初开始，版本历史如下：

1. **Windows Sockets 1.1**（版本规范了 16 位 Windows 下的标准接口，1993）  
2. **Windows Sockets 2.2**（2.2.1 版本，1997）

在 Windows 下，实现 Windows Sockets 功能都是通过 **DLL（Dynamic Link Library）** 实现的（包括 `winsock.dll`、`wsock32.dll`、`ws2_32.dll` 等）。

**Windows Sockets 1.1** 支持两种套接字：  
- 流套接字（`SOCK_STREAM`）  
- 数据报套接字（`SOCK_DGRAM`）

流套接字支持可靠的双向通信，数据报套接字是无连接并不保证可靠传输的通信方式。**Windows Sockets 2** 是 32 位扩充版，增加了多协议支持，如 QoS、Multicast 支持等。

---

### （2）进程绑定

在 TCP/IP 协议中，主机可以通过 **IP 地址** 进行寻址，但为了区分各主机上的不同进程，通常还需要 **地址和端口号**。

端口号是一个整型标识符，用于标识不同的通信进程。由于 TCP/IP 传输层有两个协议（即 TCP 和 UDP），其端口号是互相独立的。例如：
- TCP 可以有一个 2000 号端口；
- UDP 也可以有一个 2000 号端口。

---

网络通信中通信的两个进程分布在不同的机器上。在互连网络中，两台机器可能位于不同的网络，这些网络通过路由设备连接，因此需要 **三元组地址**：

1. 某主机与多个网络相连，必须指定一个特定网络地址；  
2. 每台主机上均有唯一的 IP 地址；  
3. 每一主机的每个进程都有该主机上的唯一标识符。

因此，在网络通信中，要确定通信的两个进程就必须进行相互绑定。可分为**半相关绑定**与**全相关绑定**。  
- **半相关绑定**（包括协议、本站地址、本站端口号）：可在全局唯一标志一个进程的三元组。  
- **全相关绑定**（包括协议、本站地址、本站端口号、远地地址、远地端口号）：用于标识一个完整的两端间通信的五元组。

### （3）Windows Sockets API 函数

Windows Sockets 的功能调用函数都以 **WSA（Windows Sockets Asynchronous）** 为前缀。主要函数如表 15-1 所示。

#### 表 17-1  Windows Sockets API 的主要函数

| 名称 | 说明 |
|------|------|
| **WSAStartup** | 初始化，使用 Sockets 之前必须调用 |
| **WSACleanup** | 解除与 Sockets 库的绑定并释放 Sockets 库所占用的系统资源 |
| **WSASocket** | 创建一个套接字 |
| **WSASend** | 流模式发送 |
| **WSASendTo** | 数据报方式发送 |
| **WSARecv** | 流模式接收 |
| **WSARecvFrom** | 数据报方式接收 |
| **WSAConnect** | 建立连接 |
| **bind** | BSD 绑定函数，绑定 IP 与端口 |
| **listen** | BSD 监听函数 |
| **WSAAccept / accept** | 接受连接请求 |

相关功能参数细节及其他函数请参考相应资料。

---

### （4） 面向连接和面向非连接的通信

**流套接字（SOCK_STREAM）** 和 **数据报套接字（SOCK_DGRAM）** 分别使用可靠传输的 **TCP** 和不可靠传输的 **UDP**。  
TCP 提供的是面向连接、可靠的字节流服务。当客户端和服务器彼此交换数据前，必须先在双方之间建立一个 TCP 连接，之后才能传输数据。TCP 提供超时重发、丢弃重复数据、校验数据、流量控制等功能，保证数据能从一端传输到另一端。  

UDP 是一个简单的面向数据报的传输层协议，提供的是灵活高效但不可靠的服务。它只是把应用程序传给 IP 层的数据报发送出去，但并不能保证它们能到达目的地。由于 UDP 在传输数据前不需在客户端和服务器之间建立连接，且没有超时重发等机制，故而传输速度较快。  

在设计应用时，需要根据需求选择合适的方式。一般而言：
- 需要可靠传输的（如文件传输）采用 **TCP**；
- 对速度和实时性要求高的（如实时流媒体）采用 **UDP**。

---

### （5） Windows Sockets 编程

根据开发平台的不同，采用的方式也不同，但都基于 **Windows Sockets API**。一般有以下几种方式：

1. **直接使用 Windows Sockets API**  
   所有支持调用 Windows Sockets API 的开发语言平台都可以使用此方式。其中，非连接方式是使用 UDP 进行通信，通信双方直接绑定源与目标地址。  
   使用函数 **WSASendTo()** 和 **WSARecvFrom()** 直接发送与接收，较简单；而面向连接的方式使用 **TCP** 进行通信，流程稍微复杂一些。

2. **使用开发平台封装好的控件（或组件、类库）**  
   例如在一些可视化编程平台中通过拖拽控件即可建立套接字连接。

3. **使用第三方组件（或控件、类库）**  
   通过现有的通信框架或库来快速实现网络通信功能。

---

## 17.2 实验任务及目的

在学习完 **TCP/IP 协议组** 后，要求掌握基于此协议实现网络通信，理解 **TCP 与 UDP** 的不同特性以及实现方式。  
实验要求基于 Windows 平台，建立一个基于 TCP/IP 协议的网络通信小应用，实验可采用 **UDP** 或 **TCP** 实现。  

以小组形式进行，每组 4 人。  
任务要求：建立一个基于中心服务器方式的即时数据通信平台（Instant Message，IM）。  

要求如下：

### 面向连接方式的 Socket 通信流程

#### 客户端流程
1. **WSAStartup()**：打开 Winsock，初始化 DLL。
2. **socket() 或 WSASocket()**：建立流式套接字s。
3. **connect() 或 WSAConnect()**：套接字s与服务器连接。
4. **recv()/send() 或 WSARecv()/WSASend()**：基于套接字收发数据，直到完成。
5. **closesocket()**：关闭套接字，终止 TCP 对话。
6. **WSACleanup()**：关闭 socket 调用，释放资源。

#### 服务器端流程
1. **WSAStartup()**：打开 Winsock，初始化 DLL。
2. **socket() 或 WSASocket()**：建立流式套接字，返回相应句柄。
3. **bind()**：绑定一个本地地址到套接字。
4. **listen()**：设置 backlog 值，进入监听状态。
5. **accept() 或 WSAAccept()**：等待并接受客户端连接请求。
6. **建立连接**：accept() 或 WSAAccept() 返回，等待新的套接字ns。
7. **recv()/send() 或 WSARecv()/WSASend()**：基于ns收发数据，直到完成。
8. **closesocket()**：关闭套接字ns
9. **closesocket()**：关闭监听套接字s，服务结束。
10. **WSACleanup()**：关闭 socket 调用，释放资源。

---

### 实验要求及扩展功能

1. **用户管理功能**  
   能进行用户管理，所有用户必须登录服务器端，由服务器维护在线信息。

2. **即时通信（IM）功能**  
   用户登录后可进行实时、多方、点到点、点到群的消息通信，例如聊天。

3. **服务器多线程/异步服务能力**  
   服务器应能并发处理多个客户端的连接请求与数据传输。

4. **数据存储支持**  
   使用数据库（如 SQL Server）或其他类型数据文件存储通信记录。

5. **文件传输功能**  
   支持双方文件的互传，能够显示进度。

6. **断点续传支持**  
   支持断点重传(检查时需能随时中断传送，并在下次启动时能显示重传状态)。

7. **数据加密**  
   可自定义加密算法，或利用现有平台加密模块确保通信安全。

8. **双向传输**  
   实时语音双向传送功能。

9. **多方通话功能**  
   可扩展为群聊、语音通话等实时通信。

10. **良好的界面设计与交互**  
    用户界面布局合理，信息清晰。

---

### 系统设计说明

- 对于所有功能模块，需要详细描述其用数据结构、相关算法及相应机制。
- 说明设计中的异常处理、系统框架及加密机制。
- 每个功能模块需提供实现方法及通信流程图。

---
### 基本系统结构

系统整体采用**客户端-服务器（C/S）结构**，如图 17.3 所示。  
系统主要由客户端 1、客户端 2、服务器以及消息记录模块组成。
![alt text](image-1.png)
#### 系统主要信息流

- **客户端 1 与客户端 2**  
  之间通过文件流与对话信息进行通信。
- **客户端 → 服务器**  
  上传包括登录信息与转发信息。
- **服务器 → 客户端**  
  负责下发用户在线信息与临时消息。
- **本地消息记录模块**  
  记录客户端的消息内容与交互历史。

#### 系统信息存储内容
服务器数据库需维护：
- 用户信息；
- 在线状态；
- 临时消息。

---

### 17.3 实验准备

1. 选择合适的开发语言（如 Delphi、C、C++、VB、C#、Java 或 Python 等），并准备好相应的开发平台。
2. 确保实验设备运行在 **Windows 平台**，并处于同一或相邻局域网中。
3. 安装必要的开发工具、编译器及网络调试环境。

---

### 17.4 实验步骤

使用熟悉的开发语言和平台进行程序实验，实现两台或多台主机之间的网络通信。步骤如下：

1. **技术可行性分析**  
   配置开发环境，测试工具、接口与组件包是否兼容。

2. **编写功能需求说明**  
   完成总体设计、模块划分及接口设计。

3. **项目规划与进度制定**  
   明确各阶段目标，安排开发周期与人员分工。

4. **模块实现与调试**  
   完成各功能模块后进行单元测试与集成测试，验证模块间通信与逻辑正确性。

5. **总结与文档撰写**  
   整理实验结果，撰写实验报告及系统总结文档。

---

📘 **备注：**
该系统在实现上应具备良好的模块化与扩展性，以便后续增加如加密传输、断点续传、文件共享等功能模块。

