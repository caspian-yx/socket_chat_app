# 数据库架构和同步机制说明

## 📊 当前架构概览

### 服务器端数据库

**类型**：`InMemoryRepository` (内存数据库)
**位置**：`server/storage/memory.py`
**特点**：
- ✅ **实时更新** - 所有操作立即生效
- ✅ **集中式** - 所有数据存储在服务器内存中
- ⚠️ **易失性** - 服务器重启后数据丢失（除非持久化到文件）

**存储内容**：
- 用户账号信息
- 在线状态
- 房间信息
- 离线消息队列

### 客户端数据库

**类型**：`LocalDatabase` (SQLite)
**位置**：`client/storage/local_db.py`
**特点**：
- ✅ **持久化** - 数据保存在本地文件中
- ✅ **独立存储** - 每个客户端有自己的数据库
- ⚠️ **非实时** - 只在收到消息时更新

**存储内容**：
- 消息历史记录
- 会话记录

---

## 🔄 数据同步机制

### 1. 服务器端数据 → 客户端

#### 实时同步（通过 WebSocket）

```
服务器                              客户端A                客户端B
  |                                    |                      |
  |-------- MESSAGE_EVENT ------------>|                      |
  |                                    | 收到消息              |
  |                                    | ↓                    |
  |                                    | 保存到本地数据库      |
  |                                    | ↓                    |
  |                                    | 显示在界面           |
  |                                    |                      |
  |-------- MESSAGE_EVENT ----------------------------->|
  |                                    |                 | 收到消息
  |                                    |                 | ↓
  |                                    |                 | 保存到本地数据库
  |                                    |                 | ↓
  |                                    |                 | 显示在界面
```

**触发时机**：
- 收到新消息时 → 立即保存到本地数据库
- 收到文件传输请求时 → 立即显示
- 收到语音通话请求时 → 立即弹窗

**代码位置**：
```python
# client/features/messaging.py
async def _handle_event(self, message: Dict[str, Any]) -> None:
    await self._incoming_queue.put(message)
    self.storage.save_inbound_message(message)  # 立即保存
```

#### 历史数据加载（登录时一次性）

```
客户端A                              服务器
  |                                    |
  |-------- AUTH_LOGIN --------------->|
  |                                    | 验证成功
  |<------- AUTH_LOGIN_ACK ------------|
  |                                    |
  | 加载本地历史消息                    |
  | ↓                                  |
  | 显示在界面                         |
```

**特点**：
- 登录时只加载本地数据库的历史记录
- **不会从服务器同步历史消息**（服务器不保存聊天记录）

---

## 📝 数据更新时机详解

### 消息数据

| 操作 | 服务器端 | 当前客户端 | 其他客户端 | 实时性 |
|------|---------|-----------|-----------|--------|
| **发送消息** | 不保存 | 立即保存到本地DB | 收到时立即保存 | ✅ 实时 |
| **接收消息** | 不保存 | 立即保存到本地DB | - | ✅ 实时 |
| **查看历史** | - | 从本地DB读取 | - | ⚠️ 只有本地数据 |

### 在线状态

| 操作 | 服务器端 | 所有客户端 | 实时性 |
|------|---------|-----------|--------|
| **用户上线** | 立即更新内存 | 收到 PRESENCE_EVENT 立即更新 | ✅ 实时 |
| **用户下线** | 立即更新内存 | 收到 PRESENCE_EVENT 立即更新 | ✅ 实时 |
| **心跳检测** | 实时更新最后活跃时间 | - | ✅ 实时 |

### 房间数据

| 操作 | 服务器端 | 所有客户端 | 实时性 |
|------|---------|-----------|--------|
| **创建房间** | 立即保存到内存 | 创建者立即知道 | ✅ 实时 |
| **加入房间** | 立即更新成员列表 | 房间内所有成员收到通知 | ✅ 实时 |
| **离开房间** | 立即更新成员列表 | 房间内所有成员收到通知 | ✅ 实时 |

### 文件传输

| 操作 | 服务器端 | 相关客户端 | 实时性 |
|------|---------|-----------|--------|
| **发送请求** | 转发请求 | 接收方立即收到通知 | ✅ 实时 |
| **传输进度** | 不记录 | 实时更新界面 | ✅ 实时 |
| **传输完成** | 通知双方 | 立即收到完成通知 | ✅ 实时 |

### 语音通话

| 操作 | 服务器端 | 相关客户端 | 实时性 |
|------|---------|-----------|--------|
| **发起通话** | 保存通话会话(内存) | 对方立即收到来电 | ✅ 实时 |
| **通话中** | 转发音频数据 | 实时接收音频流 | ✅ 实时 |
| **结束通话** | 立即清理会话 | 立即收到结束通知 | ✅ 实时 |

---

## ⚠️ 重要说明

### 1. 消息不会"自动同步"到所有客户端数据库

**场景举例**：
```
用户Alice有两个设备：手机A和电脑B

手机A登录 → 本地数据库A有历史消息
电脑B登录 → 本地数据库B是新的（或有旧的历史）

手机A收到新消息 → 只保存到数据库A
电脑B在线 → 也会收到这条新消息 → 保存到数据库B

电脑B离线时的消息 → 电脑B下次登录不会自动加载
```

**原因**：
- 服务器不保存聊天记录
- 只有**在线**的客户端才会收到实时消息
- 离线消息队列有限（服务器重启会丢失）

### 2. 服务器重启后数据丢失

**当前架构**：
- 服务器使用内存数据库 (`InMemoryRepository`)
- 重启后会丢失：
  - ⚠️ 用户账号（需要重新注册）
  - ⚠️ 房间信息
  - ⚠️ 在线状态
  - ✅ 客户端本地的消息历史**不会丢失**

**持久化选项**：
```python
# server/storage/memory.py
class InMemoryRepository:
    def __init__(self, db_path: str = ":memory:") -> None:
        # ":memory:" = 纯内存，重启丢失
        # "server_data.db" = 持久化到文件
```

如果需要持久化，可以修改为：
```python
repository = InMemoryRepository("server_data.db")
```

---

## 🔧 如何让数据真正实时同步

### 方案1：使用持久化服务器数据库

**步骤**：
1. 修改 `server/main.py`：
   ```python
   repository = InMemoryRepository("server_data.db")  # 使用文件存储
   ```

2. 服务器重启后数据不会丢失

### 方案2：实现离线消息同步

**需要添加**：
1. 服务器保存所有聊天记录
2. 客户端登录时从服务器拉取历史消息
3. 实现消息去重（避免重复）

**伪代码**：
```python
# 客户端登录后
async def sync_messages(self, last_sync_time):
    # 从服务器获取上次同步后的新消息
    messages = await self.network.request_history(last_sync_time)
    for msg in messages:
        self.storage.save_inbound_message(msg)
```

### 方案3：使用云数据库（企业级）

**架构**：
```
客户端A ←→ 服务器 ←→ MySQL/PostgreSQL
客户端B ←→ 服务器 ←→ MySQL/PostgreSQL
```

**优点**：
- 真正的中心化存储
- 支持多设备同步
- 数据永久保存

---

## 🎯 当前架构的实时性总结

| 数据类型 | 实时更新 | 跨设备同步 | 持久化 |
|---------|---------|-----------|--------|
| **在线用户列表** | ✅ 是 | ✅ 是 | ❌ 服务器重启丢失 |
| **新消息** | ✅ 是 | ⚠️ 仅在线设备 | ✅ 本地持久化 |
| **房间信息** | ✅ 是 | ✅ 是 | ❌ 服务器重启丢失 |
| **文件传输** | ✅ 是 | ✅ 是 | ❌ 不保存 |
| **语音通话** | ✅ 是 | ✅ 是 | ❌ 不保存 |
| **用户账号** | ⚠️ 是 | ⚠️ 是 | ❌ 服务器重启丢失 |

**结论**：
- ✅ **在线时**：所有客户端实时同步
- ⚠️ **离线时**：只能看到本地保存的历史
- ❌ **跨设备**：不同设备的消息历史不同步

---

## 📌 推荐改进

### 短期改进（简单）
1. **使用文件持久化服务器数据**
   ```python
   repository = InMemoryRepository("server_data.db")
   ```

### 中期改进（中等难度）
1. **实现离线消息同步**
2. **消息去重机制**（已部分实现）
3. **增量同步**（只同步新消息）

### 长期改进（复杂）
1. **使用真正的数据库**（MySQL/PostgreSQL）
2. **实现多设备消息同步**
3. **消息加密存储**
4. **消息搜索功能**
